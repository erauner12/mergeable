import type { Endpoint } from "./github/client"; // Import Endpoint type
import {
  fetchPullComments, // New import
  getCommitDiff,
  getPullRequestDiff,
  getPullRequestMeta,
  listPrCommits,
} from "./github/client";
import type { Pull } from "./github/types";
import { renderTemplate } from "./renderTemplate";
import * as settings from "./settings";
import type { TemplateMeta } from "./templates";
import * as templates from "./templates";
import { stripFilesListSection } from "./utils/stripFilesList"; // ADDED

/**
 * Functions for building RepoPrompt URLs and prompt text.
 * Note on URL parameters:
 * - File paths in the 'files' query parameter are individually UTF-8 percent-encoded.
 * - When reading these parameters back using `URLSearchParams.get()`, the browser automatically decodes them.
 */

/** Pushes `item` into `arr` IFF no existing element satisfies `key(item)`. */
function pushUnique<T>(arr: T[], item: T, key: (t: T) => string) {
  if (!arr.some((existing) => key(existing) === key(item))) {
    arr.push(item);
  }
}
export type LaunchMode = "workspace" | "folder";

// New: PromptMode enum and default
export type PromptMode = "implement" | "review" | "adjust-pr" | "respond";
export const defaultPromptMode: PromptMode = "implement";

// New: CommentBlockInput
export interface CommentBlockInput {
  id: string; // e.g., "pr-details", "issue-123", "review-456", "thread-file.ts-10-789"
  kind: "comment";
  header: string; // e.g., "### PR #123 DETAILS: Title", "### ISSUE COMMENT", "### REVIEW BY @user (APPROVED)"
  commentBody: string; // The actual text content
  author: string; // Login of the author or relevant name
  authorAvatarUrl?: string; // Optional avatar URL
  timestamp: string; // ISO date string
  filePath?: string; // For threads
  line?: number; // For threads
  threadId?: string; // new â€“ PR review thread (undefined for issue comments)
  diffHunk?: string; // new â€“ raw hunk text from the API
  resolved?: boolean; // â† NEW (undefined = not a code-thread or resolution unknown, false = unresolved, true = resolved)
}

// Updated: DiffBlockInput to include 'kind'
export interface DiffBlockInput {
  id: string; // New: e.g., "diff-pr", "diff-last-commit", "diff-commit-sha"
  kind: "diff";
  header: string;
  patch: string;
}

// New: PromptBlock discriminated union
export type PromptBlock = DiffBlockInput | CommentBlockInput;

export interface DiffOptions {
  includePr?: boolean;
  includeLastCommit?: boolean;
  includeComments?: boolean; // NEW
  /** @internal Currently unused by the UI â€“ always passed as `[]` from DiffPickerDialog. Kept for API compatibility. */
  commits?: string[]; // Array of commit SHAs
}

// Old DiffBlockInput (now part of the union, effectively)
// export interface DiffBlockInput {
//   header: string;
//   patch: string;
// }

/**
 * Resolved metadata about a pull request, typically derived by `buildRepoPromptUrl`.
 */
export interface ResolvedPullMeta {
  owner: string;
  repo: string;
  branch: string;
  files: string[];
  rootPath: string;
}

/** Helper to keep test output clean */
const isTestEnv = () =>
  typeof process !== "undefined" && process.env.NODE_ENV === "test";

/** Pretty-print the parameters weâ€™re about to hand to RepoPrompt */
export function logRepoPromptCall(details: {
  rootPath: string;
  workspace: string;
  branch: string;
  files: string[];
  flags: Record<string, boolean | undefined>;
  promptPreview: string;
}) {
  if (!isTestEnv()) {
    // eslint-disable-next-line no-console
    console.info("[RepoPrompt] Launch parameters:", details);
  }
}

/** The PR object we need here must expose the head-branch name. */
type PullWithBranch = Pull & { branch: string };

/** Return a stable `YYYY-Mon-DD` string in **UTC**, e.g. `2024-Jan-01`. */
function formatDateUtcShort(ts: string): string {
  const d = new Date(ts);
  const months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec",
  ];
  return `${d.getUTCFullYear()}-${months[d.getUTCMonth()]}-${String(
    d.getUTCDate(),
  ).padStart(2, "0")}`;
}

/**
 * Renamed and updated to handle single PromptBlock
 */
export function formatPromptBlock(block: PromptBlock): string {
  if (block.kind === "diff") {
    // keep the patch exactly as GitHub returned it
    return `${block.header}\n\`\`\`diff\n${block.patch}\n\`\`\``;
  } else if (block.kind === "comment") {
    const parts: string[] = [];
    if (block.diffHunk) {
      // Only threads from review comments will have diffHunk
      parts.push("```diff");
      parts.push(block.diffHunk.trim());
      parts.push("```");
      parts.push(""); // Add a newline after the diff hunk
    }

    parts.push(block.header); // e.g., "### THREAD ON ..." or "### ISSUE COMMENT ..."

    // If it's a block generated by makeThreadBlock (indicated by threadId),
    // its commentBody is already formatted with individual authors/timestamps.
    // If it's a simple issue/review comment, we need to add the author/timestamp line.
    if (block.threadId) {
      // This indicates it came from makeThreadBlock or represents a comment thread
      parts.push(block.commentBody); // This body is already fully formatted with individual comments
    } else {
      // Simple comment (e.g. issue comment, review summary, or PR description)
      const dateString = formatDateUtcShort(block.timestamp);
      parts.push(`> _${block.author} Â· ${dateString}_`);
      parts.push(""); // Newline after author line
      parts.push(block.commentBody);
    }
    // Ensure a trailing newline for the block, formatListOfPromptBlocks will handle overall trimming
    return parts.join("\n") + "\n";
  }
  return ""; // Should not happen
}

/**
 * Builds a RepoPrompt URL for a given pull request and launch mode.
 * This function no longer includes the prompt in the URL.
 * @param pull The pull request object.
 * @param launchMode The mode to launch RepoPrompt in ('workspace' or 'folder').
 * @param endpoint Optional endpoint configuration for authenticated requests.
 * @returns An object containing the final URL and resolved metadata.
 */
export async function buildRepoPromptUrl(
  pull: PullWithBranch,
  launchMode: LaunchMode = "workspace",
  endpoint?: Endpoint,
): Promise<{ url: string; resolvedMeta: ResolvedPullMeta }> {
  const baseRoot = await settings.getDefaultRoot(); // UPDATED
  if (typeof baseRoot !== "string") {
    throw new Error("getDefaultRoot did not return a string value");
  }
  const [owner, repo] = pull.repo.split("/") as [string, string];
  const rootPath = `${baseRoot}/${repo}`;

  let { branch, files } = pull;
  const token = endpoint?.auth;

  if (!branch || files.length === 0) {
    const metaFromGithub = await getPullRequestMeta(
      // Renamed to avoid conflict with 'meta' parameter in buildRepoPromptText
      owner,
      repo,
      pull.number,
      token,
      endpoint?.baseUrl, // Pass baseUrl
    );
    branch = branch || metaFromGithub.branch;
    files = files.length ? files : metaFromGithub.files;
  }

  const filesParamValue = files.map((f) => encodeURIComponent(f)).join(",");

  const query: string[] = ["focus=true"];
  let base: string;

  if (launchMode === "workspace") {
    base = "repoprompt://open";
    query.push(`workspace=${encodeURIComponent(repo)}`);
  } else {
    //  mode === "folder"
    base = `repoprompt://open/${encodeURIComponent(rootPath)}`;
    query.push("ephemeral=true");
  }

  if (files.length > 0) {
    query.push(`files=${filesParamValue}`);
  }

  query.sort();
  const finalUrl = `${base}?${query.join("&")}`;

  return {
    url: finalUrl,
    resolvedMeta: { owner, repo, branch, files, rootPath },
  };
}

// --------------------------------------------------------------------------------
// buildRepoPromptText: Main implementation
// --------------------------------------------------------------------------------
export async function buildRepoPromptText(
  pull: PullWithBranch,
  diffOptions: DiffOptions = {},
  mode: PromptMode,
  endpoint: Endpoint | undefined,
  meta: ResolvedPullMeta
): Promise<{ promptText: string; blocks: PromptBlock[] }> {
  if (!meta) {
    throw new Error(
      "ResolvedPullMeta (meta) is required for buildRepoPromptText.",
    );
  }

  // Implementation begins
  let mainTemplateString: string;
  let tplMeta: TemplateMeta;
  const userTemplateString: string | undefined = await settings.getPromptTemplate(mode); // Fetch user template
  const allPromptBlocks: PromptBlock[] = [];
  // const initiallySelectedBlocks: PromptBlock[] = []; // This seems unused now for promptText construction
  const embeddedDiffStrings: string[] = [];
  
  // Strip "files changed" section from PR body before using it.
  const originalPrBody = stripFilesListSection(pull.body ?? "");

  const { owner, repo, branch, rootPath } = meta;
  const token = endpoint?.auth;

  // Template selection and validation
  // If userTemplateString is the same as the default, analyseTemplate will be called on the default.
  // This is fine. The key is that we get a template string and its meta.
  if (userTemplateString && userTemplateString !== templates.templateMap[mode].body) {
    mainTemplateString = userTemplateString;
    tplMeta = templates.analyseTemplate(userTemplateString);
  } else {
    const defaultTemplate = templates.templateMap[mode];
    if (!defaultTemplate) {
      throw new Error(`No template found for mode: ${mode}`);
    }
    mainTemplateString = defaultTemplate.body;
    tplMeta = defaultTemplate.meta;
  }

  if (!templates.isStandard(tplMeta)) {
    throw new Error(
      `Template for mode "${mode}" is not standard. All templates must include SETUP, LINK, FILES_LIST, DIFF_CONTENT, and one of PR_DETAILS or prDetailsBlock. Please check your custom template or the default template.`,
    );
  }

  // --- Block Fetching Logic (1. Comments, 2. Full PR Diff, 3. Last Commit Diff, 4. Specific Commits Diffs) ---
  // 1. Comments, Reviews, Threads (if requested)
  if (diffOptions.includeComments) {
    if (endpoint) {
      const commentBlocks = await fetchPullComments(
        endpoint,
        owner,
        repo,
        pull.number,
      );
      commentBlocks.forEach((block) => {
        pushUnique(allPromptBlocks, block, (b) => b.id);
        // Comments are not part of the initial prompt text by default, but collected in allPromptBlocks
      });
    } else {
      console.warn("Cannot fetch comments: endpoint is undefined.");
    }
  }

  // 2. Full PR Diff
  if (diffOptions.includePr) {
    const prDiff = await getPullRequestDiff(
      owner,
      repo,
      pull.number,
      token,
      endpoint?.baseUrl,
    );
    if (prDiff.trim()) {
      const block: DiffBlockInput = {
        id: `diff-pr-${pull.id}`,
        kind: "diff",
        header: "### FULL PR DIFF",
        patch: prDiff,
      };
      pushUnique(allPromptBlocks, block, (b) => b.id);
      embeddedDiffStrings.push(formatPromptBlock(block));
    }
  }

  // 3. Last Commit Diff
  // Note: The original code had a guard rail against including both last commit and full PR diff.
  // The user's plan said: "Drop the "guard-rail" logic about includeLastCommit vs includePr â€“ leave as-is since behaviour is already correct but update comments."
  // The current code *does not* have an explicit guard rail preventing both from being added to `embeddedDiffStrings` if both options are true.
  // This means if both `includePr` and `includeLastCommit` are true, `DIFF_CONTENT` will contain both. This seems acceptable.
  if (diffOptions.includeLastCommit) {
    const prCommits = await listPrCommits(
      owner,
      repo,
      pull.number,
      1,
      token,
      endpoint?.baseUrl,
    );
    if (prCommits.length > 0) {
      const lastCommit = prCommits[0];
      if (lastCommit && lastCommit.sha) {
        const lastCommitDiff = await getCommitDiff(
          owner,
          repo,
          lastCommit.sha,
          token,
          endpoint?.baseUrl,
        );
        if (lastCommitDiff.trim()) {
          const shortSha = lastCommit.sha.slice(0, 7);
          const commitTitle = (
            lastCommit.commit.message || "No commit message"
          ).split("\n")[0];
          const block: DiffBlockInput = {
            id: `diff-last-commit-${lastCommit.sha}`,
            kind: "diff",
            header: `### LAST COMMIT (${shortSha} â€” "${commitTitle}")`,
            patch: lastCommitDiff,
          };
          pushUnique(allPromptBlocks, block, (b) => b.id);
          embeddedDiffStrings.push(formatPromptBlock(block));
        }
      }
    }
  }

  // 4. Specific Commits Diffs
  if (diffOptions.commits && diffOptions.commits.length > 0) {
    const allPrCommitsForMessages = await listPrCommits(
      owner,
      repo,
      pull.number,
      250, // Max commits to fetch for messages
      token,
      endpoint?.baseUrl,
    );
    const commitMessageMap = new Map(
      allPrCommitsForMessages.map((c) => [
        c.sha,
        (c.commit.message || "No commit message").split("\n")[0],
      ]),
    );
    for (const sha of diffOptions.commits) {
      const commitDiff = await getCommitDiff(
        owner,
        repo,
        sha,
        token,
        endpoint?.baseUrl,
      );
      if (commitDiff.trim()) {
        const shortSha = sha.slice(0, 7);
        const commitTitle =
          commitMessageMap.get(sha) || "Unknown commit message";
        const block: DiffBlockInput = {
          id: `diff-commit-${sha}`,
          kind: "diff",
          header: `### COMMIT (${shortSha} â€” "${commitTitle}")`,
          patch: commitDiff,
        };
        pushUnique(allPromptBlocks, block, (b) => b.id);
        embeddedDiffStrings.push(formatPromptBlock(block));
      }
    }
  }

  // FILES_LIST slot - always populated
  let filesListString = "";
  if (meta.files && meta.files.length > 0) {
    const filesListContent = meta.files.map((f) => `- ${f}`).join("\n");
    // The template itself will contain "### files changed"
    filesListString = filesListContent;
  } else {
    // The template itself will contain "### files changed"
    filesListString = "No files changed in this PR.";
  }


  // PR Details Block (content for PR_DETAILS slot, but no longer added to allPromptBlocks)
  const prDetailsCommentBody = originalPrBody; // Already stripped
  const prDetailsBlockForSlotFormatting: CommentBlockInput = { // Renamed to clarify its purpose
    id: `pr-details-${pull.id}`, // ID is still useful for potential direct formatting if needed elsewhere
    kind: "comment",
    header: `PR #${pull.number} DETAILS: ${pull.title}`,
    commentBody: prDetailsCommentBody,
    author: pull.author?.name ?? "unknown",
    authorAvatarUrl: pull.author?.avatarUrl,
    timestamp: pull.createdAt,
  };
  // pushUnique(allPromptBlocks, prDetailsBlockForSlotFormatting, (b) => b.id); // REMOVED: PR details block is not added to the selectable blocks list.
  // It's rendered into the prompt via slots only.

  // Prepare content for template slots
  const setupString = [
    `cd ${rootPath}`,
    "git fetch origin",
    `git checkout ${branch}`,
  ].join("\n");

  const prDetailsString = formatPromptBlock(prDetailsBlockForSlotFormatting); // Format for slot insertion
  const diffContentString = embeddedDiffStrings.join("\n\n").trim();
  const linkString = `ðŸ”— ${pull.url.includes("/pull/") ? pull.url : `https://github.com/${owner}/${repo}/pull/${pull.number}`}`;
  
  // This logic correctly handles providing content for {{prDetailsBlock}}
  // only if the template expects it AND NOT {{PR_DETAILS}}.
  const prDetailsContentForBlockToken = tplMeta.expectsPrDetails
    ? ""
    : prDetailsString;

  const allSlots = {
    SETUP: setupString,
    PR_DETAILS: prDetailsString, // Populated if template uses {{PR_DETAILS}}
    FILES_LIST: filesListString,
    DIFF_CONTENT: diffContentString,
    LINK: linkString,
    prDetailsBlock: prDetailsContentForBlockToken, // Populated if template uses {{prDetailsBlock}} (and not PR_DETAILS)
  };

  // Since we now only support standard templates, the logic simplifies.
  // renderTemplate will clean up any unused tokens or empty lines.
  // The removeMarker option for FILES_LIST is no longer needed as the marker is removed from templates.
  const promptText = renderTemplate(mainTemplateString, allSlots);


  // --- ensure deterministic order for the `blocks` array returned to UI: PR first, then other comments, then diffs
  const uniqueAllPromptBlocks = Array.from(
    new Map(allPromptBlocks.map((b) => [b.id, b])).values(),
  ).sort((a, b) => {
    const rank = (x: PromptBlock) =>
      x.id.startsWith("pr-details") ? 0 : x.kind === "comment" ? 1 : 2;
    return rank(a) - rank(b);
  });

  return { promptText, blocks: uniqueAllPromptBlocks };
}